# -*- org-src-preserve-indentation: t; -*-

#+STARTUP: content

* Package archives and setup
** Package archives
#+BEGIN_SRC emacs-lisp
(require 'package)
(setq package-archives '(("gnu" . "https://elpa.gnu.org/packages/")
			 ("melpa" . "https://melpa.org/packages/")
			 ("org" . "http://orgmode.org/elpa/")))
(setq package-user-dir (expand-file-name "elpa" user-emacs-directory)
      package-enable-at-startup nil
      package--init-file-ensured t
      package-check-signature nil)
#+END_SRC

** Use-package
Install use-package and its sub-packages/necessary packages for some of its extra features

#+BEGIN_SRC emacs-lisp
(require 'package)

(unless package--initialized
  (package-initialize))

(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(require 'use-package)
(setq use-package-always-ensure nil)

(use-package delight :ensure t)
(use-package bind-key :ensure t)
(use-package use-package :ensure t)
#+END_SRC

* Environment
** Custom Variables
#+BEGIN_SRC emacs-lisp
;; Constants
(defconst *is-mac* (eq system-type 'darwin))
(defconst *is-linux* (eq system-type 'gnu/linux))
(defconst *pretty-mode* nil)

;; General variables
(defvar detvdl/font-list '())

;; Directories
(defconst emacs-misc-dir (expand-file-name "misc" user-emacs-directory))
(defconst emacs-theme-dir (expand-file-name "themes" user-emacs-directory))
#+END_SRC

* MacOS specifics
** Modifiers
Switch up modifier keys to fit the MacOS keyboard layout better
#+BEGIN_SRC emacs-lisp
(when *is-mac*
  (setq mac-command-modifier 'control
        mac-control-modifier 'meta
        mac-option-modifier 'alt)
  (global-set-key [kp-delete] 'delete-char))
#+END_SRC

** Looks
Prettify Emacs appearance to match colour scheme
#+BEGIN_SRC emacs-lisp
(when (and *is-mac* *pretty-mode*)
  (add-to-list 'default-frame-alist
               '(ns-transparent-titlebar . t)))
#+END_SRC

** Bugs
Fix visual select bug
#+BEGIN_SRC emacs-lisp
(fset 'evil-visual-update-x-selection 'ignore)
#+END_SRC

* Paths and custom file locations
** Load path initialization
#+BEGIN_SRC emacs-lisp
(push emacs-theme-dir custom-theme-load-path)
(dolist (dir (directory-files emacs-theme-dir))
  (let ((dirpath (expand-file-name dir emacs-theme-dir)))
    (unless (or (member dir '("." ".." ".git"))
		(not (file-directory-p dirpath)))
      (push dirpath custom-theme-load-path))))

(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(when (file-exists-p custom-file)
  (load custom-file))
#+END_SRC

* Shell
** Environment variables
#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
  :ensure t
  :config
  (dolist (var '("SSH_AUTH_SOCK"
                 "SSH_AGENT_PID"
                 "GPG_AGENT_INFO"
                 "GPG_TTY"
                 "GOPATH"
                 "LANG"
                 "LC_CTYPE"
                 "LC_ALL"
                 "LANG"
                 "LANGUAGE"
                 "PAGER"
                 "TERM"))
    (add-to-list 'exec-path-from-shell-variables var))
  (when (memq window-system '(mac ns))
    (exec-path-from-shell-initialize)))
#+END_SRC

* UI
** GUI
Remove unnecessary cruft from the GUI application

#+BEGIN_SRC emacs-lisp
(tool-bar-mode -1)
(menu-bar-mode -1)
(scroll-bar-mode -1)
(blink-cursor-mode -1)
(show-paren-mode 1)


(global-display-line-numbers-mode)
(setq display-line-numbers-width 4
      display-line-numbers-current-absolute t
      display-line-numbers-widen t)

(column-number-mode)

(setq inhibit-splash-screen nil)
(setq ring-bell-function 'ignore)

(setq-default indicate-empty-lines t)

(setq frame-resize-pixelwise t)

(setq scroll-margin 0
      scroll-conservatively 100000
      scroll-preserve-screen-position 1)
#+END_SRC

Zoom in and out using text-scale commands

#+BEGIN_SRC emacs-lisp
(bind-key "C--" #'text-scale-decrease global-map)
(bind-key "C-+" #'text-scale-increase global-map)
#+END_SRC

** Fonts
#+BEGIN_SRC emacs-lisp
(defconst font-height 140)
(defconst Go-font `(:family "Go Mono" :height ,font-height))

(setq detvdl/font-list (append detvdl/font-list
			                   '(Go-font)))

(defun detvdl/transform-font-list (fonts)
  (mapcar (lambda (font)
	        (cons (plist-get (symbol-value font) :family) font))
	      fonts))

(defun detvdl/switch-font (&optional font)
  (interactive)
  (let* ((fonts (detvdl/transform-font-list detvdl/font-list))
	     (font-name (or font (completing-read
			                  "Pick font: "
			                  (mapcar 'car fonts)
			                  nil
			                  t)))
	     (font (symbol-value (alist-get font-name fonts))))
    (set-frame-font (apply 'font-spec font) nil t)))

(set-frame-font (apply 'font-spec Go-font) nil t)
(setq line-spacing 0.1)
#+END_SRC

** Theme
#+BEGIN_SRC emacs-lisp
(mapc #'disable-theme custom-enabled-themes)
(load-theme 'leuven t)
#+END_SRC

** Modeline
#+BEGIN_SRC emacs-lisp
(which-function-mode)
#+END_SRC

* Editor
** General
#+BEGIN_SRC emacs-lisp
;; smart tab behavior - indent or complete
(setq tab-always-indent 'complete)
#+END_SRC

Never type "yes" or "no" again.

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

Always delete selection when typing over or pasting

#+BEGIN_SRC emacs-lisp
(delete-selection-mode +1)
#+END_SRC

Remove trailing whitespace when saving a file

#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

Automatically create missing parent directories when visiting a new file.

#+BEGIN_SRC emacs-lisp
(defun detvdl/create-non-existent-directory ()
      (let ((parent-directory (file-name-directory buffer-file-name)))
        (when (and (not (file-exists-p parent-directory))
                   (y-or-n-p (format "Directory '%s' does not exist! Create it?" parent-directory)))
          (make-directory parent-directory t))))
(add-to-list 'find-file-not-found-functions #'detvdl/create-non-existent-directory)
#+END_SRC

Some generic variables.

#+BEGIN_SRC emacs-lisp
(setq-default tab-width 4
	          make-backup-files nil
	          indent-tabs-mode nil
	          show-trailing-whitespace t
	          visible-bell nil)
#+END_SRC

Show me which line I'm on.

#+BEGIN_SRC emacs-lisp
(global-hl-line-mode +1)
#+END_SRC

Proper line wrapping.

#+BEGIN_SRC emacs-lisp
(global-visual-line-mode +1)
(delight 'visual-line-mode nil t)
#+END_SRC

Uniquify buffers with the same name instead of appending a number.

#+BEGIN_SRC emacs-lisp
(setq uniquify-buffer-name-style 'forward
      uniquify-separator " . "
      uniquify-after-kill-buffer-p t
      uniquify-ignore-buffers-re "^\\*")
#+END_SRC

Have proper undo/redo behaviour

#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :ensure t
  :delight
  :bind (("C-/" . undo)
         ("C-S-/" . undo-tree-redo))
  :config
  (global-undo-tree-mode +1))
#+END_SRC

Auto revert buffers that changed on disk

#+BEGIN_SRC emacs-lisp
(auto-revert-mode +1)
(delight 'auto-revert-mode nil t)
#+END_SRC

** Clipboard
#+BEGIN_SRC emacs-lisp
(when *is-linux*
  (setq x-select-enable-clipboard t))
(setq select-active-regions t)
(setq save-interprogram-paste-before-kill 1)
(setq yank-pop-change-selection t)
#+END_SRC

** General Utilities
Easily select regions.
#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :ensure t
  :bind (("C-=" . er/expand-region)
         ("C-. e" . er/expand-region)))
#+END_SRC

Quickly switch windows, with visual help
#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :ensure t
  :delight ace-window-mode
  :bind ("M-o" . ace-window)
  :config
  (setq aw-keys '(?a ?r ?s ?d ?h ?n ?e ?i ?o)
        aw-dispatch-always nil))
#+END_SRC

Edit multiple occurences of a code fragment in one buffer.
Used in combination with ivy/swiper and rg for easy refactoring.
#+BEGIN_SRC emacs-lisp
(use-package wgrep
  :ensure t
  :defer t
  :config
  (setq wgrep-auto-save-buffer t))
#+END_SRC

Helper functions to improve some emacs basics.
#+BEGIN_SRC emacs-lisp
(use-package crux
  :ensure t
  :bind (([(shift return)] . crux-smart-open-line)
         ([(control shift return)] . crux-smart-open-line-above)
         ("C-a" . crux-move-beginning-of-line)
         ("C-k" . crux-kill-whole-line)
         ("C-<backspace>" . crux-kill-line-backwards))
  :config
  (crux-reopen-as-root-mode))
#+END_SRC

Handy-dandy menu in case you ever forget a keybind.
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :ensure t
  :delight which-key-mode
  :config
  (which-key-mode))
#+END_SRC

Great regex-based find-and-replace.
#+BEGIN_SRC emacs-lisp
(use-package anzu
  :ensure t
  :bind (("C-, r" . anzu-query-replace)
         ("C-, R" . anzu-query-replace-regexp)))
#+END_SRC

Quickly select expanding regions and put them in the kill-ring.
#+BEGIN_SRC emacs-lisp
(use-package easy-kill
  :ensure t
  :bind (([remap kill-ring-save] . easy-kill)
         ([remap mark-sexp] . easy-mark)))
#+END_SRC

Does what it says: multiple cursors!
#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :ensure t
  :defer t
  :bind (("C->" . mc/mark-next-like-this)
         ("C-<" . mc/mark-previous-like-this)
         ("C-M-<" . mc/unmark-previous-like-this)
         ("C-M->" . mc/unmark-next-like-this)
         ("C-. C->" . mc/skip-to-next-like-this)
         ("C-. C-<" . mc/skip-to-previous-like-this)
         ("C-. >" . mc/mark-all-like-this)
         ("C-; w" . mc/mark-all-words-like-this)
         :map global-map
         ("C-S-<mouse-1>" . mc/add-cursor-on-click))
  :init
(setq mc/list-file (expand-file-name ".mc-lists.el" emacs-misc-dir)))
#+END_SRC

** Ivy
#+BEGIN_SRC emacs-lisp
(use-package ivy
  :ensure t
  :delight ivy-mode
  :bind (("C-s" . counsel-grep-or-swiper)
         ("C-x C-f" . counsel-find-file)
	 ("M-x" . counsel-M-x)
	 ("M-X" . smex-major-mode-commands)

         ("C-c y" . counsel-yank-pop)
         ("C-c k" . counsel-rg)
         ("C-x l" . counsel-locate)
         ("C-h v" . counsel-describe-variable)
         ("C-h f" . counsel-describe-function)
         ("C-x 8" . counsel-unicode-char)
         ("C-x b" . ivy-switch-buffer)
	 ("C-c C-r" . ivy-resume)
         ("C-c C-u" . swiper-all)
         ("C-c C-w" . ivy-wgrep-change-to-wgrep-mode)
         :map ivy-minibuffer-map
         ("RET" . ivy-alt-done)
         ("C-m" . ivy-alt-done)
         ("C-j" . ivy-done))
  :config
  ;; Fuzzy matching
  (use-package flx :ensure t)
  (setq ivy-use-virtual-buffers t
        ivy-use-selectable-prompt t
        enable-recursive-minibuffers t
        ivy-display-style 'fancy
        ivy-height 8
        ivy-virtual-abbreviate 'full
        ivy-extra-directories nil
        ivy-re-builders-alist '((swiper . ivy--regex-plus)
                                (t . ivy--regex-plus)))
  (use-package smex
    :ensure t
    :config
    (setq smex-save-file (expand-file-name "smex-items" emacs-misc-dir)))
  ;; use the faster ripgrep for standard counsel-grep
  (setq counsel-grep-base-command "rg -i -M 120 --no-heading --line-number --color never '%s' %s")
  (ivy-mode 1))

(use-package swiper :ensure t :after ivy)
(use-package counsel :ensure t :after ivy)

(use-package ivy-rich
  :ensure t
  :after ivy
  :init (setq ivy-rich-parse-remote-file-path t)
  :config (ivy-rich-mode 1))
#+END_SRC

* Org-mode
** General
Install org from org-plus-contrib!

#+BEGIN_SRC emacs-lisp
(use-package org
  :ensure org-plus-contrib
  :pin org
  :mode ("\\.org\\'" . org-mode)
  :bind (("C-c l" . org-store-link)
         ("C-c a" . org-agenda)
         ("C-c b" . org-iswitchb))
  :config
  (setq org-log-done t
        org-startup-indented t
        org-hidden-keywords '()
        ;; LaTeX preview size is a bit too small for comfort
        org-format-latex-options (plist-put org-format-latex-options :scale 2.0)
        org-highlight-latex-and-related '(latex))
  ;; I *kinda* like distinctive header sizes
  (custom-set-faces
   '(org-document-title ((t (:inherit outline-1 :height 1.30 :underline t))))
   '(org-document-info ((t (:inherit outline-1 :height 1.20))))
   '(org-document-info-keyword ((t (:inherit outline-1 :height 1.20))))
   '(org-warning ((t (:weight bold :foreground "#CC9393" :height 1.20))))

   '(org-level-1 ((t (:inherit outline-1 :height 1.05))))
   '(org-level-2 ((t (:inherit outline-2 :height 1.00))))
   '(org-level-3 ((t (:inherit outline-3 :height 1.00))))
   '(org-level-4 ((t (:inherit outline-4 :height 1.00))))
   '(org-level-5 ((t (:inherit outline-5 :height 1.00))))
   ))

(delight 'org-indent-mode nil t)
#+END_SRC

Org-mode buffer-local variables

#+BEGIN_SRC emacs-lisp
(put 'org-src-preserve-indentation 'safe-local-variable (lambda (val) #'booleanp))
#+END_SRC

** Look & feel
Prettifying org-mode buffers.
#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :ensure t
  :after org
  :hook (org-mode . org-bullets-mode)
  :config
  (setq org-bullets-bullet-list '("◉"
                                  "○")))

(use-package adaptive-wrap
  :ensure t
  :hook (org-mode . adaptive-wrap-prefix-mode)
  :config
  (progn
    (setq-default adaptive-wrap-extra-indent 2)))
#+END_SRC

* Completion
** Snippets
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :if (not noninteractive)
  :ensure t
  :delight
  :commands (yas-reload-all yas-minor-mode)
  :hook (prog-mode . yas-minor-mode))

(use-package yasnippet-snippets
  :ensure t
  :after yasnippet)

#+END_SRC

** Company
#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :delight company-mode
  :bind (("M-\\" . company-select-next))
  :demand
  :config
  (setq company-idle-delay 0.5
        company-tooltip-limit 10
        company-minimum-prefix-length 2
        company-tooltip-flip-when-above t
        company-tooltip-align-annotations t)
  (global-company-mode 1))

(use-package company-quickhelp
  :ensure t
  :after company
  :config
  (use-package pos-tip :ensure t)
  (company-quickhelp-mode 1)
  (setq company-quickhelp-delay 0.5
        company-quickhelp-use-propertized-text t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(bind-key "M-\\" #'company-complete-common-or-cycle global-map)

(defun company:add-local-backend (backend)
  "Add the BACKEND to the local `company-backends' variable."
  (if (local-variable-if-set-p 'company-backends)
      (add-to-list 'company-backends `(,backend :with company-yasnippet))
    (add-to-list (make-local-variable 'company-backends)
                 `(,backend :with company-yasnippet))))
#+END_SRC

* Programming tools
** Comment Keywords
#+BEGIN_SRC emacs-lisp
(defun local-comment-auto-fill ()
  (set (make-local-variable 'comment-auto-fill-only-comments) t))

(defun font-lock-comment-annotations ()
  "Highlight a bunch of well known comment annotations.
This functions should be added to the hooks of major modes for programming."
  (font-lock-add-keywords
   nil '(("\\<\\(\\(FIX\\(ME\\)?\\|TODO\\|OPTIMIZE\\|HACK\\|REFACTOR\\|NOTE\\|WARNING\\):\\)"
          1 font-lock-warning-face t))))

(add-hook 'prog-mode-hook (lambda ()
                            (local-comment-auto-fill)
(font-lock-comment-annotations)))
#+END_SRC

** Compilation mode
#+BEGIN_SRC emacs-lisp
;; colorize the output of the compilation mode.
(require 'ansi-color)
(defun colorize-compilation-buffer ()
  (toggle-read-only)
  (ansi-color-apply-on-region (point-min) (point-max))

  ;; mocha seems to output some non-standard control characters that
  ;; aren't recognized by ansi-color-apply-on-region, so we'll
  ;; manually convert these into the newlines they should be.
  (goto-char (point-min))
  (while (re-search-forward "\\[2K\\[0G" nil t)
    (progn
      (replace-match "")))
  (toggle-read-only))
(add-hook 'compilation-filter-hook 'colorize-compilation-buffer)
#+END_SRC

** Encoding & Transient buffers
#+BEGIN_SRC emacs-lisp
(put 'encoding 'safe-local-variable (lambda (val) #'stringp))
#+END_SRC

Don't replace existing buffers with transient ones, keep them persistent.
#+BEGIN_SRC emacs-lisp
(use-package dedicated
  :ensure t
  :commands dedicated-mode)
#+END_SRC

** Magit
#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :bind (("C-x g" . magit-status))
  :config
  (setq magit-completing-read-function 'ivy-completing-read
        magit-restore-window-configuration #'detvdl/magit-visit-pull-request
        vc-follow-symlinks t)
  (use-package other-frame-window
    :ensure t
    :config
    (defun magit-display-buffer-popup-frame (buffer)
      (if (with-current-buffer buffer (eq major-mode 'magit-status-mode))
          (display-buffer buffer '((display-buffer-reuse-window
                                    ofw-display-buffer-other-frame)
                                   (reusable-frames . t)))
        (magit-display-buffer-traditional buffer)))
    (setq magit-display-buffer-function #'magit-display-buffer-popup-frame))
  (advice-add #'magit-key-mode-popup-committing :after
              (lambda ()
                (magit-key-mode-toggle-option (quote committing) "--verbose"))))
#+END_SRC

Visual diff feedback in the margin/gutter

#+BEGIN_SRC emacs-lisp
(use-package diff-hl
  :ensure t
  :config
  (set-face-attribute 'diff-hl-change nil :height font-height)
  (set-face-attribute 'diff-hl-delete nil :height font-height)
  (set-face-attribute 'diff-hl-insert nil :height font-height)
  (global-diff-hl-mode +1)
  (diff-hl-flydiff-mode +1)
  (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh))
#+END_SRC

Don't let ediff create any fancy layouts, just use a proper, separate buffer.

#+BEGIN_SRC emacs-lisp
(use-package ediff
  :ensure t
  :config
  (setq ediff-window-setup-function 'ediff-setup-windows-plain))
#+END_SRC

** Smartparens
#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :ensure t
  :delight smartparens-mode
  :hook ((prolog-mode prog-mode ess-mode slime-mode slime-repl-mode) . smartparens-mode)
  :bind (("C-. )" . sp-rewrap-sexp)
         ("C-. (" . sp-rewrap-sexp))
  :config
  (require 'smartparens-config)
  (setq sp-base-key-bindings 'paredit
        sp-autoskip-closing-pair 'always
        sp-hybrid-kill-entire-symbol nil)
  (sp-use-paredit-bindings)
  ;; TODO: add and fix pairs for Clojure-specific constructs
  (sp-pair "{" nil :post-handlers
           '(((lambda (&rest _ignored)
                (crux-smart-open-line-above)) "RET")))
  (sp-pair "{" nil :post-handlers
           '(("||\n[i]" "RET")
             ("| " "SPC")))
  (sp-pair "[" nil :post-handlers
           '(((lambda (&rest _ignored)
                (crux-smart-open-line-above)) "RET")))
  (sp-pair "[" nil :post-handlers
           '(("||\n[i]" "RET")
             ("| " "SPC"))))
#+END_SRC

** Projectile
#+BEGIN_SRC emacs-lisp
(use-package projectile
  :ensure t
  :delight projectile-mode
  :bind (("C-c p p" . projectile-switch-project)
         ("C-c p f" . projectile-find-file))
  :config
  (setq projectile-completion-system 'ivy)
  (with-eval-after-load 'ivy
    (ivy-set-actions 'projectile-find-file
                     '(("j" find-file-other-window "other window")))
    (ivy-set-actions 'projectile-switch-project
                     '(("g" magit-status "magit status"))))
  (projectile-mode))
#+END_SRC

** Rainbows
#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :ensure t
  :hook ((lisp-mode emacs-lisp-mode clojure-mode slime-mode) . rainbow-delimiters-mode))
#+END_SRC

** Documentation
Always enable eldoc
#+BEGIN_SRC emacs-lisp
(global-eldoc-mode +1)
#+END_SRC

** Error checking
#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :ensure t
  :config
  (global-flycheck-mode +1))
#+END_SRC

** Indentation
Aggressively indent everything (except for basically all non-lisp modes)!

#+BEGIN_SRC emacs-lisp
(use-package aggressive-indent
  :ensure t
  :diminish aggressive-indent-mode
  :hook ((lisp-mode lisp-interaction-mode emacs-lisp-mode clojure-mode) . aggressive-indent-mode)
  :config
  (defvar aggressive-indent/excluded '())
  (setq aggressive-indent/excluded '(html-mode ruby-mode python-mode yaml-mode))
  (dolist (i aggressive-indent/excluded)
    (add-to-list 'aggressive-indent-excluded-modes i))
  (add-to-list
   'aggressive-indent-dont-indent-if
   '(and (or (derived-mode-p 'c-mode)
             (eq major-mode 'rust-mode))
         (null (string-match "\\([;{}]\\|\\b\\(if\\|for\\|while\\)\\b\\)"
                             (thing-at-point 'line))))))
#+END_SRC

Utility function to re-indent entire file

#+BEGIN_SRC emacs-lisp
(defun detvdl/indent-file ()
  (interactive)
  (indent-region (point-min) (point-max)))
(bind-key "C-; l" #'detvdl/indent-file global-map)
#+END_SRC

Emacs-lisp does not indent keyword-plists correctly. This function fixes that

#+BEGIN_SRC emacs-lisp
;; https://github.com/Fuco1/.emacs.d/blob/af82072196564fa57726bdbabf97f1d35c43b7f7/site-lisp/redef.el#L20-L94
(defun Fuco1/lisp-indent-function (indent-point state)
  "This function is the normal value of the variable `lisp-indent-function'.
The function `calculate-lisp-indent' calls this to determine
if the arguments of a Lisp function call should be indented specially.
INDENT-POINT is the position at which the line being indented begins.
Point is located at the point to indent under (for default indentation);
STATE is the `parse-partial-sexp' state for that position.
If the current line is in a call to a Lisp function that has a non-nil
property `lisp-indent-function' (or the deprecated `lisp-indent-hook'),
it specifies how to indent.  The property value can be:
,* `defun', meaning indent `defun'-style
  \(this is also the case if there is no property and the function
  has a name that begins with \"def\", and three or more arguments);
,* an integer N, meaning indent the first N arguments specially
  (like ordinary function arguments), and then indent any further
  arguments like a body;
,* a function to call that returns the indentation (or nil).
  `lisp-indent-function' calls this function with the same two arguments
  that it itself received.
This function returns either the indentation to use, or nil if the
Lisp function does not specify a special indentation."
  (let ((normal-indent (current-column))
        (orig-point (point)))
    (goto-char (1+ (elt state 1)))
    (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
    (cond
     ;; car of form doesn't seem to be a symbol, or is a keyword
     ((and (elt state 2)
           (or (not (looking-at "\\sw\\|\\s_"))
               (looking-at ":")))
      (if (not (> (save-excursion (forward-line 1) (point))
                  calculate-lisp-indent-last-sexp))
          (progn (goto-char calculate-lisp-indent-last-sexp)
                 (beginning-of-line)
                 (parse-partial-sexp (point)
                                     calculate-lisp-indent-last-sexp 0 t)))
      ;; Indent under the list or under the first sexp on the same
      ;; line as calculate-lisp-indent-last-sexp.  Note that first
      ;; thing on that line has to be complete sexp since we are
      ;; inside the innermost containing sexp.
      (backward-prefix-chars)
      (current-column))
     ((and (save-excursion
             (goto-char indent-point)
             (skip-syntax-forward " ")
             (not (looking-at ":")))
           (save-excursion
             (goto-char orig-point)
             (looking-at ":")))
      (save-excursion
        (goto-char (+ 2 (elt state 1)))
        (current-column)))
     (t
      (let ((function (buffer-substring (point)
                                        (progn (forward-sexp 1) (point))))
            method)
        (setq method (or (function-get (intern-soft function)
                                       'lisp-indent-function)
                         (get (intern-soft function) 'lisp-indent-hook)))
        (cond ((or (eq method 'defun)
                   (and (null method)
                        (> (length function) 3)
                        (string-match "\\`def" function)))
               (lisp-indent-defform state indent-point))
              ((integerp method)
               (lisp-indent-specform method state
                                     indent-point normal-indent))
              (method
               (funcall method indent-point state))))))))

(add-hook 'emacs-lisp-mode-hook
          (lambda () (setq-local lisp-indent-function #'Fuco1/lisp-indent-function)))
#+END_SRC

* Languages
** Lisp
Some common functionality for all lisp-like languages (akin to smartparens)
#+BEGIN_SRC emacs-lisp
(defun wrap-with (s)
  `(lambda (&optional arg)
     (interactive "P")
     (sp-wrap-with-pair ,s)))

(bind-key "TAB" #'completion-at-point read-expression-map)
(bind-key "M-(" (lambda () (wrap-with "(")) lisp-mode-shared-map)
(bind-key "M-\"" (lambda () (wrap-with "\"")) lisp-mode-shared-map)
#+END_SRC

** Emacs Lisp
#+BEGIN_SRC emacs-lisp
(use-package elisp-slime-nav
  :ensure t
  :defer t
  :commands (elisp-slime-nav-mode))

(dolist (hook '(emacs-lisp-mode-hook ielm-mode-hook))
  (add-hook hook 'elisp-slime-nav-mode))

(add-hook 'emacs-lisp-mode-hook (lambda () (company:add-local-backend 'company-elisp)))
#+END_SRC

** Common Lisp
#+BEGIN_SRC emacs-lisp
;; the SBCL configuration file is in Common Lisp
(add-to-list 'auto-mode-alist '("\\.sbclrc\\'" . lisp-mode))

;; Open files with .cl extension in lisp-mode
(add-to-list 'auto-mode-alist '("\\.cl\\'" . lisp-mode))

(use-package slime
  :ensure t
  :commands slime
  :bind (:map slime-mode-map
         ("C-c C-s" . slime-selector))
  :config
  (setq slime-lisp-implementations '((ccl ("/usr/local/bin/ccl"))
                                     (sbcl ("/usr/local/bin/sbcl"))
                                     (pico ("/usr/local/bin/pil")))
        slime-contribs '(slime-fancy slime-company slime-indentation)
        slime-autodoc-use-multiline-p t
        slime-enable-evaluate-in-emacs t
        common-lisp-style-default "sbcl")
  (defun slime-enable-concurrent-hints ()
    (interactive)
    (setf slime-inhibit-pipelining nil)))

(use-package slime-company
  :ensure t
  :after slime
  :config
  (add-hook 'slime-mode-hook (lambda () (company:add-local-backend 'company-slime)))
  (setq slime-company-completion 'fuzzy))
#+END_SRC

** Clojure
#+BEGIN_SRC emacs-lisp
(use-package clojure-mode
  :ensure t
  :mode ("\\.clj[xc]?\\'"
         "build\\.boot\\'")
  :config
  (add-hook 'clojure-mode-hook #'subword-mode))

(add-to-list 'auto-mode-alist '("\\.cljs\\'" . clojurescript-mode))

(use-package cider
  :ensure t
  :defer t
  :commands cider-jack-in
  :config
  (progn
    (setq nrepl-log-messages t
          ;; cider-boot-parameters "dev"
          cider-eldoc-display-context-dependent-info t
          cider-eldoc-display-for-symbol-at-point t
          cider-dynamic-indentation nil)
    (add-hook 'cider-mode-hook #'subword-mode)
    (add-hook 'cider-mode-hook #'eldoc-mode)
    (add-hook 'cider-repl-mode-hook #'cider-company-enable-fuzzy-completion)
    (add-hook 'cider-mode-hook #'cider-company-enable-fuzzy-completion)
    (add-hook 'cider-repl-mode-hook #'eldoc-mode)))

(use-package clojure-snippets
  :ensure t
  :after clojure-mode
  :config
  (with-eval-after-load 'yasnippet
    (clojure-snippets-initialize)))

#+END_SRC

** C-like modes
#+BEGIN_SRC emacs-lisp
(use-package cc-mode
  :ensure nil
  :mode (("\\.h\\(h?\\|xx\\|pp\\)\\'" . c++-mode)
         ("\\.m\\'" . c-mode)
         ("\\.mm\\'" . c++-mode)
         ("\\.java\\'" . java-mode))
  :init
  (defun c-mode-common-defaults ()
    (setq c-default-style "gnu"
          c-basic-offset 4
          c-tab-always-indent t)
    (c-set-offset 'substatement-open 0)
    ;; make the underscore part of a word in C and C++ modes
    (modify-syntax-entry ?_ "w" c++-mode-syntax-table)
    (modify-syntax-entry ?_ "w" c-mode-syntax-table))
  (when (derived-mode-p 'c-mode 'c++-mode 'java-mode)
    (c-mode-common-defaults)))

(defun makefile-mode-defaults ()
  (whitespace-toggle-options '(tabs))
  (setq indent-tabs-mode t))

(add-hook 'makefile-mode-hook #'makefile-mode-defaults)
#+END_SRC

** Go
#+BEGIN_SRC emacs-lisp
(use-package go-mode
  :ensure t
  :mode "\\.go\\'")

(use-package company-go
  :ensure t
  :after go-mode
  :config
  (add-hook 'go-mode-hook (lambda () (company:add-local-backend 'company-go))))
#+END_SRC

** Ruby
#+BEGIN_SRC emacs-lisp
(use-package ruby-mode
  :ensure t
  :mode ("\\.rake\\'"
         "Rakefile\\'"
         "\\.gemspec\\'"
         "\\.ru\\'"
         "Gemfile\\'"
         "Guardfile\\'"
         "Capfile\\'"
         "\\.cap\\'"
         "\\.thor\\'"
         "\\.rabl\\'"
         "Thorfile\\'"
         "Vagrantfile\\'"
         "\\.jbuilder\\'"
         "Podfile\\'"
         "\\.podspec\\'"
         "Puppetfile\\'"
         "Berksfile\\'"
         "Appraisals\\'")
  :interpreter "ruby"
  :config
  (add-hook 'ruby-mode-hook #'subword-mode))

(use-package yari
  :ensure t
  :defer t)

(use-package inf-ruby
  :ensure t
  :bind (:map inf-ruby-minor-mode-map
         ("C-x C-e" . ruby-send-last-sexp))
  :hook (ruby-mode . inf-ruby-minor-mode))

(use-package ruby-tools
  :ensure t
  :hook (ruby-mode . ruby-tools-mode))

(use-package rbenv
  :ensure t
  :defer t
  :config
  (global-rbenv-mode)
  (rbenv-use-corresponding))

(use-package robe
  :ensure t
  :hook (ruby-mode . robe-mode)
  :config
  (add-hook 'robe-mode (lambda () (company:add-local-backend 'company-robe))))

(use-package rubocop
  :ensure t
  :hook (ruby-mode . rubocop-mode))

(use-package feature-mode
  :ensure t
  :mode (("\\.feature$" . feature-mode)))
#+END_SRC

** (X)HTML & CSS
#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :ensure t
  :mode ("\\.phtml\\'"
         "\\.tpl\\.php\\'"
         "\\.tpl\\'"
         "\\.blade\\.php\\'"
         "\\.jsp\\'"
         "\\.as[cp]x\\'"
         "\\.erb\\'"
         "\\.html?\\'"
         "\\.eex\\'"
         "/\\(views\\|html\\|theme\\|templates\\)/.*\\.php\\'")
  :config
  (setq web-mode-enable-auto-pairing nil
        web-mode-enable-current-element-highlight t)
  (eval-after-load 'smartparens
    (sp-with-modes '(web-mode)
      (sp-local-pair "%" "%"
                     :unless '(sp-in-string-p)
                     :post-handlers '(((lambda (&rest _ignored)
                                         (just-one-space)
                                         (save-excursion (insert " ")))
                                       "SPC" "=" "#")))
      (sp-local-tag "%" "<% "  " %>")
      (sp-local-tag "=" "<%= " " %>")
      (sp-local-tag "#" "<%# " " %>"))))

(use-package emmet-mode
  :ensure t
  :bind (:map emmet-mode-keymap
         ("TAB" . emmet-expand-line))
  :hook ((web-mode sgml-mode css-mode) . emmet-mode))

(use-package css-mode
  :ensure t
  :mode ("\\.[s]?css\\'")
  :config
  (setq css-indent-offset 2))

;; Pretty colours for css-mode
(use-package rainbow-mode
  :ensure t
  :after css-mode
  :hook css-mode)
#+END_SRC

** JavaScript
#+BEGIN_SRC emacs-lisp
(use-package js2-mode
  :ensure t
  :mode ("\\.js\\'"
         "\\.pac\\'")
  :interpreter "node"
  :config
  (add-hook 'js2-mode-hook (lambda ()
                             (setq-local electric-layout-rules
                                         '((?\; . after)))
                             (setq mode-name "JS2"
                                   js-indent-level 2)))
  (js2-imenu-extras-mode +1))

(use-package tern
  :ensure t
  :delight
  :hook js2-mode)

(use-package company-tern
  :ensure t
  :after tern
  :config
  (add-hook 'js2-mode-hook (lambda () (company:add-local-backend 'company-tern))))

(use-package json-mode
  :ensure t
  :mode ("\\.json\\'"))
#+END_SRC

** Typescript
#+BEGIN_SRC emacs-lisp
(use-package typescript-mode
  :ensure t
  :mode "\\.ts\\'")

(use-package tide
  :ensure t
  :after (typescript-mode company flycheck)
  :hook ((typescript-mode . tide-setup)
         (typescript-mode . tide-hl-identifier-mode)
         (before-save . tide-format-before-save)))
#+END_SRC

** Markdown
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :ensure t
  :commands (markdown-mode gfm-mode)
  :mode (("README\\.md\\'" . gfm-mode)
         ("\\.md\\'" . markdown-mode)
         ("\\.markdown\\'" . markdown-mode))
  :config (setq markdown-command "multimarkdown"))

(use-package pandoc-mode
  :ensure t
  :hook markdown-mode
  ;; :magic ("README" . (lambda () (pandoc-mode -1)))
  :config
  (add-hook 'pandoc-mode-hook 'pandoc-load-default-settings)
  ;; We don't need pandoc-mode in github-flavored .md files
  (add-hook 'gfm-mode-hook (lambda () (pandoc-mode -1))))

(use-package yaml-mode
  :ensure t
  :mode "\\.yml\\'")
#+END_SRC

* Custom Functions
** General
Start emacs from within emacs!

#+BEGIN_SRC emacs-lisp
(defun start-emacs ()
  (interactive)
  (call-process (executable-find "emacs") nil 0 nil))
#+END_SRC

Handy functions to URL-encode/-decode a region

#+BEGIN_SRC emacs-lisp
(defun url-encode-region (beg end)
  "URL encode the region between BEG and END."
  (interactive "r")
  (if (use-region-p)
      (let* ((selected-text (buffer-substring beg end))
             (encoded-text (url-hexify-string selected-text)))
        (kill-region beg end)
        (insert encoded-text))))

(defun url-decode-region (beg end)
  "URL decode the region between BEG and END."
  (interactive "r")
  (if (use-region-p)
      (let* ((selected-text (buffer-substring beg end))
             (decoded-text (url-unhex-string selected-text)))
        (kill-region beg end)
        (insert decoded-text))))
#+END_SRC
